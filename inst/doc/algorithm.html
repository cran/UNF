<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>The UNF Algorithm</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>





<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{The UNF Algorithm}
-->

<h1>The UNF Algorithm</h1>

<p>This vignette describes the UNF algorithm (Altman, Gill, McDonald 2003; Altman and King 2007; Altman 2008) and the R implementation thereof, which includes some peculiarities. The official specifications for various versions of UNF can be found elsewhere online. The algorithm is described in general terms <a href="http://guides.dataverse.org/en/latest/developers/unf/index.html">here</a> and one can also find more specific descriptions of the <a href="http://guides.dataverse.org/en/latest/developers/unf/unf-v3.html">Version &frac34;</a>, <a href="http://guides.dataverse.org/en/latest/developers/unf/unf-v5.html">Version 5</a> and <a href="http://guides.dataverse.org/en/latest/developers/unf/unf-v6.html">Version 6</a> algorithms.</p>

<p>The current version of this package is an R implementation that relies on general implementations of the relevant hash functions provided by <a href="https://cran.r-project.org/package=digest">digest</a> and base64 encoding provided by <a href="https://cran.r-project.org/package=base64enc">base64enc</a>. Versions 1 and 2 were available in an earlier version of the UNF package authored by Micah Altman, which was built on custom C libraries, and is included in the version logs on GitHub. That package was orphaned by CRAN in 2009. The package retains the core <code>unf()</code> function from the earlier versions of the UNF package, but simplifies its use considerably. The package additionally implements some new helper functions.</p>

<h2>(1) Numerics</h2>

<p>Round numerics to <em>k</em> digits, where the default value of <em>k</em> is 7. (Note: In UNF versions &lt;= 5, <em>k</em> was labeled <em>n</em>.) Then, convert those numerics to a character-class string containing exponential notation in the following form:</p>

<pre><code>- A sign character
- A single leading non-zero digit
- A decimal point
- Up to *k*-1 remaining digits following the decimal, no trailing zeros
- A lowercase letter &quot;e&quot;
- A sign character
- The digits of the exponent, omitting trailing zeros
</code></pre>

<p>Note (a): Zero can be positive (&ldquo;+0.e+&rdquo;) or negative (&ldquo;-0.e+&rdquo;).</p>

<p>Note (b): <code>Inf</code>, <code>-Inf</code>, and <code>NaN</code> are represented as: &ldquo;+inf&rdquo;, &ldquo;-inf&rdquo;, and &ldquo;+nan&rdquo;, respectively. At some point in time, Dataverse handled non-finites by treating them as missing.</p>

<p>Note &copy;: The <a href="http://dataverse.org/">Dataverse</a> implementation of UNFv5 represents zero values (and logical <code>FALSE</code>) values as &ldquo;+0.e-6&rdquo; rather than the implied &ldquo;+0.e+&rdquo; (like logical <code>TRUE</code> values: &ldquo;+1.e+&rdquo;). This can be replicated in <code>unf5()</code> by adding the argument <code>dvn_zero = TRUE</code>.</p>

<h2>(2) Character Strings</h2>

<p>Truncate character strings to <em>l</em> characters, where the default value of <em>l</em> is 128. (Note: In UNF versions &lt;= 5, <em>l</em> was labeled <em>k</em>.)</p>

<h2>(3) Other Data Classes</h2>

<p>Handle other types of data in the following ways.</p>

<ol>
<li>For UNF versions &lt; 5, convert all non-numeric data to character and handle as in (2), above.</li>
<li><p>For UNF versions &gt;= 5:</p>

<p>a. Convert logical values to numeric (<code>TRUE</code> is &ldquo;1&rdquo; and <code>FALSE</code> is &ldquo;0&rdquo;) and handle as in (1), above.</p>

<p>b. In this package, &ldquo;factor&rdquo; and &ldquo;AsIs&rdquo; class vectors are coerced to character and handled as in (2), above.</p>

<p>c. Treat bits (raw) variables as base64-encoded big-endian bit sequences.</p>

<p>d. Handle dates, times, and datetimes as in (4), below. In this package, time-series classes (&ldquo;ts&rdquo; and &ldquo;zoo&rdquo;) and &ldquo;difftime&rdquo; class objects are coerced to numeric.</p>

<p>e. Format complex numbers as <code>A,iB</code>, where <code>A</code> is the real component and and <code>B</code> is the complex component and both are formatted as numeric values as in (1), above.</p></li>
</ol>

<h2>(4) Dates, times, datetimes, intervals, and durations</h2>

<p>Dates, times, datetimes, intervals, and durations are handled as follows:</p>

<p>a. Dates are converted to character strings in the form &ldquo;YYYY-MM-DD&rdquo;, but partial dates (&ldquo;YYYY&rdquo; and &ldquo;YYYY-MM&rdquo;) are permitted. (Note: Partial dates are not supported in R, but one can create character representations of partial dates in the package by specifying <code>date_format</code>.)</p>

<p>b. Times are converted to character strings using the ISO 8601 format &ldquo;hh:mm:ss.fffff&rdquo;. &ldquo;fffff&rdquo; is fractions of a second and must not containing trailing zeroes (as with any numeric value, see [1], above). The time should be expressed in UTC time with a terminal &ldquo;Z&rdquo; character. (Note: Times without accompanying dates are not supported in R, and thus not implemented in the package.)</p>

<p>c. Datetimes may be expressed as a concatenated date (only in the form &ldquo;YYYY-MM-DD&rdquo;) and time, separated by &ldquo;T&rdquo;. As an example, Fri Aug 22 12:51:05 EDT 2014 is encoded as: <code>&quot;2014-08-22T16:51:05Z&quot;</code>.</p>

<p>d. Intervals are represented as two datetimes, concatenated by a &ldquo;/&rdquo;. (Note: Intervals are not supported in R, and thus not implemented in the package.)</p>

<p>Note: Given the different implementation of timezones in different programming languages and software applications, UNF signatures calculated for identical datasets in different applications may differ. For example, the UNFv6 specification notes that Stata does not implement time zones, while R always assumes a timezone. The suggested work around is to convert variables to a string representation and handle as in (2), above.</p>

<h2>Computing the UNF</h2>

<ol>
<li><p>Append all non-missing values with an end-of-line (<code>\n</code>) character and a single null byte. Represent all missing values as a string of three null bytes. (Note: At some point in time, Dataverse appeared to treat empty character strings <code>&quot;&quot;</code> as missing values. As of UNFv6, this is explicit that a missing value <code>NA</code> is represented by only three null bytes and an empty character string <code>&quot;&quot;</code> is represented by an end-of-line character and a null byte.)</p></li>
<li><p>Convert to Unicode bit encoding. For UNF versions &lt; 4.1, use <a href="http://en.wikipedia.org/wiki/UTF-32BE">UTF-32BE</a>. For UNF versions &gt;= 4.1, use <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a>.</p></li>
<li><p>Concatenate all values into a single byte sequence. Compute a hash on the resulting byte sequence. For UNF versions &gt; 3, use <a href="http://en.wikipedia.org/wiki/SHA-2">SHA256</a>. For UNF version 3, use <a href="http://en.wikipedia.org/wiki/MD5">MD5</a>. </p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Base64">Base64 encode</a> the resulting hash. For UNF versions &gt;= 5, truncate the UNF by performing base64 encoding only on the leftmost 128, 192, 196, or 256 bits, where 128 bits (16 bytes) is the default.</p></li>
</ol>

<p><strong>To aggregate multiple variables:</strong></p>

<ol>
<li><p>Calculate the UNF for each variable, as above.</p>

<p>Note (a): For one-variable datasets, Dataverse implements the algorithm at the variable-level only, without aggregation. Thus a UNF for a one-variable dataframe is the same as the UNF for that variable alone. The standard is ambiguous in this regard and the package copies the Dataverse implementation.</p>

<p>Note (b): The package treats dataframes and lists identically. Matrices are coerced to dataframes before running the algorithm.</p></li>
<li><p>Sort the base64-encoded UNFs in POSIX locale order.</p></li>
<li><p>Apply the UNF algorithm to the sorted, base64-encoded UNFs, using a truncation value as large as the original, treating the UNFs as character. For UNF versions &gt;= 5, the algorithm is applied to the truncated UNFs.</p></li>
</ol>

<p><strong>To aggregate multiple datasets:</strong></p>

<ol>
<li><p>Calculate the UNF for each dataset, as above.</p></li>
<li><p>Sort the base64-encoded UNFs in POSIX locale order.</p></li>
<li><p>Apply the UNF algorithm to the sorted, base64-encoded UNFs, using a truncation value as large as the original, treating the UNFs as character. For UNF versions &gt;= 5, the algorithm is applied to the truncated UNFs.</p>

<p>Note: Multiple datasets need to be combined based on UNFs calculated with the same version of the algorithm. Thus when calculating a study-level UNF, dataset-level UNFs need to be calculated using the same version of the algorithm. (To achieve this, Dataverse recalculates old UNFs whenever new data is added to a study.)</p></li>
</ol>

<h2>Reporting the UNF</h2>

<p>The UNF is intended to be used as part of a data citation, for example:</p>

<blockquote>
<p>James Druckman; Jordan Fein; Thomas Leeper, 2012, &ldquo;Replication data for: A Source of Bias in Public Opinion Stability&rdquo;, <a href="http://hdl.handle.net/1902.1/17864">http://hdl.handle.net/1902.1/17864</a> UNF:5:esVZKwuUnh5kkpDhxXKLxA==</p>
</blockquote>

<p>Here, a citation to the data file includes a persistent handle URI and a UNF signature specifying a specific version of the data file available from that handle. Note the UNF is printed as with a small header indicating the algorithm version, making it easy to match any particular UNF against a data file:</p>

<pre><code>UNF:[UNF version]:[UNF hash]
</code></pre>

<p>In UNFv5, the header might also contain details of other parameters for non-default number rounding and character string truncation, respectively: </p>

<pre><code>UNF:[UNF version]:[digits],[characters]:[UNF hash]
</code></pre>

<p>In UNFv6, the header can contain a number rounding parameter (N), a string truncation parameter (X), and a variable-level UNF hash truncation parameter (H) (in any order):</p>

<pre><code>UNF:[UNF version]:N[digits],X[characters],H[bits]:[UNF hash]
</code></pre>

<p>The package prints each UNF in the appropriate format, including any non-default parameters when appropriate.</p>

<h2>References</h2>

<p>Altman, Micah, Jeff Gill and Michael P. McDonald.  2003. <em>Numerical Issues in Statistical Computing for the Social Scientist</em>.  John Wiley &amp; Sons. <em>(Describes version 3 of the algorithm)</em></p>

<p>Altman, Micah, &amp; Gary King. 2007. &ldquo;A Proposed Standard for the Scholarly Citation of Quantitative Data.&rdquo; <em>D-Lib</em> 13(&frac34;). <a href="http://dlib.org/dlib/march07/altman/03altman.html">http://dlib.org/dlib/march07/altman/03altman.html</a>.</p>

<p>Altman, Micah 2008. &ldquo;A Fingerprint Method for Scientific Data Verification.&rdquo; In T. Sobh, editor, <em>Advances in Computer and Information Sciences and Engineering</em>, chapter 57, pp. 311-316. Springer Netherlands, Netherlands. <a href="http://link.springer.com/chapter/10.1007/978-1-4020-8741-7_57">http://link.springer.com/chapter/10.1007/978-1-4020-8741-7_57</a>. <em>(Describes version 5 of the algorithm)</em></p>

<p>Data Citation Synthesis Group. 2013. &ldquo;Declaration of Data Citation Principles.&rdquo;</p>

<p>Altman, Michah, and Merce Crosas. 2014. &ldquo;The Evolution of Data Citation: From Principles to Implementation.&rdquo; <em>IASSIST QUARTERLY</em>, Forthcoming. <a href="http://thedata.org/files/thedata_new2/files/altmancrosasiassistqforthcoming.pdf">http://thedata.org/files/thedata_new2/files/altmancrosasiassistqforthcoming.pdf</a>.</p>

</body>

</html>
